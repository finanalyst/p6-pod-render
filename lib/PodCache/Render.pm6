#! /usr/bin/env perl6
use v6.c;

=begin pod
=TITLE Rendering pod

This module provides functionality to take a precompiled pod and generate
output based on templates. To the extent possible, all rendering specific (eg. html)
code is moved to templates.

All templates can be over-ridden.


=begin SYNOPSIS

    use PodCache::Render;

    my PodCache::Render $renderer .= new(
        :path<path-to-pod-cache>,
        :templates<path-to-templates>,
        :output<path-to-output>,
        :rendering<html>,
        :assets<path-to-assets-folder>,
        );

    # Utility  functions

    $renderer.template-test;
    $renderer.gen-templates('path-for-template-output');
    $renderer.gen-index-files('path-for-the-pod6-output');
    $renderer.test-index('path-to-config');

=end SYNOPSIS
=item new
=item2 instantiates object and verifies cache is present
=item2 creates or empties the output directory
=item2 sets up templates from default or over-riding directory

=item path
=item2 location of perl6 compunit cache, as generated by Pod::To::Cached
=item2 defaults to '.pod-cache'

=item templates
=item2 location of templates root directory
=item2 defaults to C<resources/templates>, which is where a complete set of templates exists

=item rendering
=item2 the type of rendering chosen
=item2 default is html, and refers to templates/html in which a complete set of templates exists
=item2 any other valid directory name can be used, eg md, so long as templates/md contains a complete set of templates
=item2 Individual templates can be over-ridden by providing it in the templates/html directory

=item output
=item2 the path where output is sent
=item2 default is a directory with the same name as C<rendering>

=item assets
=item2 path to a directory which may have subdirectories, eg.  C<js>, C<css>, C<images>
=item2 the subdirectories/files are copied to the C<output> directory

=item config
=item2  path to a directory containing configuration files (see below)
=item2 configuration files are rendered into a html files with links to the pod files.

=item global-links
=item2 boolean default False
=item2 if true href links in <a> tags must all be relative to collection (podfile appended to local link)
=item2 if false links need only be unique relative to Processed

=head1 Usage

All the required templates are provided in the default directory, and a css file called C<pod.css> is in a default C<assets> directory.

However, when there is a large collection of documents, more complex pages are required. Typically, the template C<file-wrap.mustache>
is over-ridden and custom css, js, and image files are included.

The file-wrap template is called with the following elements:

=item    :title generated from the pod file's V<=TITLE>
=item    :subtitle generated from the pod file's V<=SUBTITLE>
=item    :metadata generated from the pod file's V<=AUTHOR, =SUMMARY, etc >
=item    :toc generated from the pod file's V<=HEAD>
=item    :index generated from the pod file's V< X<> elements>
=item    :footnotes generated from the pod file's V<N<> elements>
=item    :body generated from the pod file
=item    :path a string containing the original path of the POD6 file (if the doc-cache retains the information)

=head Configuration

By default - that is without a config file - a single index file, called C<index.pod6>, is generated with the documents in the top directory of the cache listed by
TITLE, followed by the SUBTITLE, followed by the Table of Content for the cache file.
If the cache has subdirectories, then the name of the directory is made into a title, and the files under it are listed as above.

A separate file called C<global-index.pod6> is generated containing
the indexed elements from all the pod-files in the cache.

These two pod files are then converted by the renderer into html (by default), but if a different rendering has been specified, they will follow those rendering
templates.

If a C<config> directory is provided, Render will look for C<*.pod6> files and consider them customised index files.

Each will be converted from C<name.pod6> to C<name.B<ext>> where B<ext> is C<html> by default, but could
be C<md> if the rendering is to Markdown. The configuration files are themselves rendered using the template C<config-file>, which can be amended
as required.

For an html page, one of the configuarations should typically be C<index.html>. It is for the user to ensure that C<index.pod6> contains links to other
index files.

The structure of the configuration file is as follows

V<=begin> Configuration

V<=TITLE> Text for title
V<=SUBTITLE> text for a preamble

V<=head> text for section heading

Text about section
V<=item> filename :link-name<link> :toc<False>
V<=item> filename2

V<=head> next section header
etc etc
V<=end> Configuration

=head Utilities

=item template-test
=item2 Generates a list of template names that have been over-ridden.

=item gen-templates('path-name')
=item2 'path-name' is interpreted as a directory, which must exist. All the mustache templates will be copied into it.
=item2 Only the templates required may be kept. Some templates, such as C<zero> do not need to be over-ridden as there is no rendering data.

=item gen-index-files('path-name')
=item2 'path-name' is a directory that must exist
=begin item2
the two index files C<index.pod6> and C<global-index.pod6> are generated in that directory. The intent is to provide templates for
customised config files
=end item2

=item test-index('path-name')
=item2 'path-name' is a directory that should contain the config files.
=item2 each pod6 file will be read and the filenames from V<=item> lines will be compared to the files in the doc-cache
=item2 any file present in I<the doc-cache>, but B<not> included in I<a config file> will be output into a config file called C<misc.pod6>
=item2 any filename included in I<a config file>, but B<not> in I<the doc-cache>, will be listed in a file called C<error.txt>

=end pod

use JSON::Fast;
use nqp;
use Pod::To::Cached;
use PodCache::Engine;
use PodCache::Processed;

no precompilation;
unit class PodCache::Render is Pod::To::Cached;

constant TEMPLATES = 'resources/templates';
constant RENDERING = 'html';

has PodCache::Engine $.engine;
has Bool $!global-links; # whether links must be unique to collection (True), or to Pod file (Default False)
has Bool $.verbose is rw;
has Bool $.debug is rw;
has $!templates;
has $!rendering;
has $!output;
has %.pfiles;
has @.global-index;

submethod BUILD(
    :$!templates = TEMPLATES,
    :$!rendering = RENDERING,
    :$!output = $!rendering,
    :$!global-links = False,
    :$!verbose = False,
    :$!debug = False,
    ) {}

submethod TWEAK {
    $!engine .= new(:default( TEMPLATES ~ '/' ~ RENDERING ), :$!templates, :$!rendering);
    $!engine.verify-templates;
}

method gen-templates($path) {
    die "｢$path｣ must be a directory." unless $path.IO ~~ :d;
    for $!engine.tmpl.kv -> $nm, $str { "$path/$nm.mustache".IO.spurt: $str }
}

method gen-index-files($path) {
    die "｢$path｣ must be a directory." unless $path.IO ~~ :d;
    self.process-cache;
    my @names =
        (gather for $.files.keys {
            take %( :name($_), :v([ .split('/')  ]) )  #gives a hash with origin and sort target
        }).sort({ .<v>.elems, .<v>.[0], .<v>.[1], .<v>.[2], .<v>.[3], .<v>.[4], .<v>.[5], .<v>.[6] }) #shortest first, then by part
            .map( { %(:name(.<name>), :level(.<v>.elems), :fn( .<v>.pop ), :dir( .<v>.join('/') ) ) } ) # rewrite elements to a hash
        ;    #should be no more than 7 layers
    my @items ;
    my $last-head = '';
    for @names {
        @items.push( %(:header( %(:level(.<level>), :text(.<dir>))))) if .<dir> ne $last-head;
        $last-head = .<dir>;
        @items.push( %{:item( %(
            :title( %!pfiles{ .<name> }.title),
            :name( .<name> ),
            :subtitle( %!pfiles{ .<name> }.sub-title ),
            :toc( %!pfiles{ .<name> }.render-toc )
        ))} )
    };
    "$path/index.pod6".IO.spurt: $!engine.rendition('config-file', {:items( @items )} )
}

method body-wrap( PodCache::Processed $pf --> Str ) {
    $!engine.rendition('body-wrap', {
        :name($pf.name),
        :title($pf.title),
        :subtitle($pf.sub-title),
        :metadata($pf.render-meta),
        :toc( $pf.render-toc ),
        :index( $pf.render-index),
        :footnotes( $pf.render-footnotes ),
        :body( $pf.pod-body ),
        :path( $pf.path )
    })
}

multi method file-wrap( PodCache::Processed $pf, :$name = $pf.name ) {
    "$!output/$name.html".IO.spurt: $!engine.rendition('file-wrap', {
        :$name,
        :orig-name($pf.name),
        :title($pf.title),
        :subtitle($pf.sub-title),
        :metadata($pf.render-meta),
        :toc( $pf.render-toc ),
        :index( $pf.render-index),
        :footnotes( $pf.render-footnotes ),
        :body( $pf.pod-body ),
        :path( $pf.path )
    } )
}

method processed-instance(:$name ) {
    PodCache::Processed.new(
        :$name,
        :pod-tree( self.pod($name) ),
        :path( $.files{$name}<path> ),
        :$!global-links,
        :templater( $!engine ),
        :$!debug,
        :$!verbose
    )
}

method process-cache {
    return if +%.pfiles.keys;
    for $.files.keys -> $filename {
        %.pfiles{$filename} = self.processed-instance( $filename );
    }
}

method template-test {
    $!engine.over-ridden, "from $!templates/$!rendering"
}
