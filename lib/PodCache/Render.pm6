#! /usr/bin/env perl6
use v6.c;

=begin pod
=TITLE Rendering pod

This module provides functionality to take a precompiled pod and generate
output based on templates. To the extent possible, all rendering specific (eg. html)
code is moved to templates.

All templates can be over-ridden.

Pod file names are assumed to have no spaces in them.

=begin SYNOPSIS

    use PodCache::Render;

    my PodCache::Render $renderer .= new(
        :path<path-to-pod-cache>,
        :templates<path-to-templates>,
        :output<path-to-output>,
        :rendering<html>,
        :assets<path-to-assets-folder>,
        :config<path-to-config-folder>,
        :clear-output,
        );

    # Utility  functions

    $renderer.templates-changed;
    $renderer.gen-templates;
    $renderer.gen-index-files;
    $renderer.test-index;

=end SYNOPSIS
=item new
=item2 instantiates object and verifies cache is present
=item2 creates or empties the output directory
=item2 sets up templates from default or over-riding directory

=item path
=item2 location of perl6 compunit cache, as generated by Pod::To::Cached
=item2 defaults to '.pod-cache'

=item templates
=item2 location of templates root directory
=item2 defaults to C<resources/templates>, which is where a complete set of templates exists

=item rendering
=item2 the type of rendering chosen
=item2 default is html, and refers to templates/html in which a complete set of templates exists
=item2 any other valid directory name can be used, eg md, so long as templates/md contains a complete set of templates
=item2 Individual templates can be over-ridden by providing it in the templates/html directory

=item output
=item2 the path where output is sent
=item2 default is a directory with the same name as C<rendering> in the current working directory
=item2 if C<output> does not exist, then a Fatal Exception will be thrown.

=item assets
=item2 path to a directory which may have subdirectories, eg.  C<js>, C<css>, C<images>
=item2 the subdirectories/files are copied to the C<output> directory

=item config
=item2  path to a directory containing configuration files (see below)
=item2 configuration files are rendered into a html files with links to the pod files.

=item global-links
=item2 boolean default False
=item2 if true href links in <a> tags must all be relative to collection (podfile appended to local link)
=item2 if false links need only be unique relative to Processed

=item clear-output
=item2 boolean default False
=item2 Empty output directory, if it already exists
=item2 The intent is for only tainted files to be overwritten, and for existing files to be left

=head1 Usage

All the required templates are provided in the default directory, and a css file called C<pod.css> is in a default C<assets> directory.

However, when there is a large collection of documents, more complex pages are required. Typically, the template C<file-wrap.mustache>
is over-ridden and custom css, js, and image files are included.

The file-wrap template is called with the following elements:

=item    :title generated from the pod file's V<=TITLE>
=item    :subtitle generated from the pod file's V<=SUBTITLE>
=item    :metadata generated from the pod file's V<=AUTHOR, =SUMMARY, etc >
=item    :toc generated from the pod file's V<=HEAD>
=item    :index generated from the pod file's V< X<> elements>
=item    :footnotes generated from the pod file's V<N<> elements>
=item    :body generated from the pod file
=item    :path a string containing the original path of the POD6 file (if the doc-cache retains the information)

=head Configuration

By default - that is without any configuration file(s) - a single index file, called C<index.B<ext>>, is generated with the documents
in the top directory of the cache listed by
TITLE, followed by the SUBTITLE, followed by the Table of Content for the cache file.
If the cache has subdirectories, then the name of the directory is made into a title, and the files under it are listed as above.

A separate file called C<global-index.B<ext>> is generated containing
the indexed elements from all the pod-files in the cache.

These two files are rendered into html (by default), but if a different rendering has been specified, they will follow those rendering
templates.

If a C<config> directory is provided, Render will look for C<*.yaml> files and consider them customised index files.

Each will be converted from C<name.yaml> to C<name.B<ext>> where B<ext> is C<html> by default, but could, eg,
be C<md> if the rendering is to Markdown.

The indexation files are rendered using the template C<indexation>, which can be amended
as required.

For an html page, one of the configuarations should typically be C<index.html>.

For more information, generate a template configuration file into a directory (see below).

=head Utilities

=item templates-changed
=item2 Generates a list of template names that have been over-ridden.

=item gen-templates
=item2 'templates/rendering' is interpreted as a directory, which must exist. All the mustache templates will be copied into it.
=item2 Only the templates required may be kept. Some templates, such as C<zero> do not need to be over-ridden as there is no rendering data.

=item gen-index-files
=item2 C<config> is a writable directory that must exist, defaults to C<output>
=begin item2
    the two index files C<index.yaml> and C<global-index.yaml> are generated in that directory. The intent is to provide templates for
    customised config files. For more information generate a template.
=end item2
=item2 The index filenames themselves are generated using the C<indexation> template
=item2 the extension of the final index files will be the same as C<rendering>
=item2 the filename of the index file will be same as the +.yaml files in the config directory

=item test-index-files
=item2 C<config> is a directory that should contain the config files.
=item2 if no .yaml files are in the config directory, the method will throw a Fatal Exception.
=item2 each pod6 file will be read and the filenames from V<=item> lines will be compared to the files in the doc-cache
=item2 any file present in I<the doc-cache>, but B<not> included in I<a config file> will be output into a config file called C<misc.pod6>
=item2 any filename included in I<a config file>, but B<not> in I<the doc-cache>, will be listed in a file called C<error.txt>

=end pod

use JSON::Fast;
use nqp;
use Pod::To::Cached;
use PodCache::Engine;
use PodCache::Processed;
use YAMLish;
use File::Directory::Tree;
use Data::Dump;
use LibCurl::Easy;

no precompilation;
unit class PodCache::Render is Pod::To::Cached;

constant TEMPLATES = 'resources/templates';
constant RENDERING = 'html';
constant ASSETS = 'resources/assets';

has PodCache::Engine $.engine;
has Bool $!global-links; # whether links must be unique to collection (True), or to Pod file (Default False)
has Bool $.verbose is rw;
has Bool $.debug is rw;
has $!templates;
has $!rendering;
has $!output;
has Bool $!output-test; # caches the result of the output directory test
has Bool $.clear-output;

has $!config;
has $!assets;

has %.pfiles;
has @!names; # ordered array of hash of names in cache, with directory paths
has %.global-index;
has @.global-links;

submethod BUILD(
    :$!templates = TEMPLATES,
    :$!rendering = RENDERING,
    :$!output = $!rendering,
    :$!config = $!rendering,
    :$!assets = ASSETS,
    :$!global-links = False,
    :$!verbose = False,
    :$!debug = False,
    :$!clear-output = False,
    ) {}

submethod TWEAK {
    $!engine .= new(:default( TEMPLATES ~ '/' ~ RENDERING ), :$!templates, :$!rendering);
    $!engine.verify-templates;
}

method gen-templates {
    die "It does not seem that a new template and rendering directory have been given"
        unless ( TEMPLATES ~ '/' ~ RENDERING ).IO ne "$!templates/$!rendering".IO;
    die "｢$!templates/$!rendering｣ must be a writable directory for Templates." unless "$!templates/$!rendering".IO ~~ :d;
    for $!engine.tmpl.kv -> $nm, $str { "$!templates/$!rendering/$nm.mustache".IO.spurt: $str }
}

method gen-index-files {
    die "｢$!config｣ must be a writable directory." unless $!config.IO ~~ :d;
    self.make-names unless +@!names;
    self.process-cache;
    my @params ;
    my $last-head = '';
    for @!names {
        @params.push( %(:header( %(:level(.<level>), :text(.<dir>))))) if .<dir> ne $last-head;
        $last-head = .<dir>;
        @params.push( %(:item(  :filename( .<name> ) )) )
    };
    @params
        .push( %(:head( %( :level(1), :text('Global Index'), ) ) ) )
        .push(%(:item( %(:title('Index to all items in source files'), :link("global-index.$!rendering"), ) ) ) )
        ; # add to the bottom a link to the global index file.
    "$!config/index.yaml".IO.spurt: data('index-start') ~ save-yaml(%( :content( @params ) ,) ).subst(/^^  '---' $$ \s /,''); #take the top --- off the yaml file, its in data.
    "$!config/global-index.yaml".IO.spurt: data('global-index-start') ~ save-yaml(%( :content( proforma( +%.global-index.keys ) ) ,) ).subst(/^^  '---' $$ \s /,'')
}

method make-names {
    @!names =
        (gather for $.files.keys {
            take %( :name($_), :v([ .split('/')  ]) )  #gives a hash with origin and sort target
        }).sort({ .<v>.elems, .<v>.[0], .<v>.[1], .<v>.[2], .<v>.[3], .<v>.[4], .<v>.[5], .<v>.[6] }) #shortest first, then by part
            .map( { %(:name(.<name>), :level(.<v>.elems), :fn( .<v>.pop ), :dir( .<v>.join('/') ) ) } ) # rewrite elements to a hash
        ;    #should be no more than 7 layers
}

method body-wrap( PodCache::Processed $pf --> Str ) {
    $!engine.rendition('body-wrap', {
        :name($pf.name),
        :title($pf.title),
        :subtitle($pf.sub-title),
        :metadata($pf.render-meta),
        :toc( $pf.render-toc ),
        :index( $pf.render-index),
        :footnotes( $pf.render-footnotes ),
        :body( $pf.pod-body ),
        :path( $pf.path )
    })
}

method file-wrap( PodCache::Processed $pf, :$name = $pf.name ) {
    unless $!output-test {
        if $!clear-output {
            rmtree $!output
        }
        unless "$!output/assets".IO.d {
            mktree("$!output/assets") or die "Cannot create output directory at $!output/assets";
            for $!assets.IO.dir { .copy: "$!output/assets/" ~ .basename }
        }
        $!output-test = True;
    }
    # note that if $name has / chars, the file will be in a subdirectory
    unless "$!output/$name".IO.dirname.IO ~~ :d {
        mktree "$!output/$name".IO.dirname # make sure the sub-directory exists in the output directory
    }
    "$!output/$name.$!rendering".IO.spurt: $!engine.rendition('file-wrap', {
        :$name,
        :orig-name($pf.name),
        :title($pf.title),
        :subtitle($pf.sub-title),
        :metadata($pf.render-meta),
        :toc( $pf.render-toc ),
        :index( $pf.render-index),
        :footnotes( $pf.render-footnotes ),
        :body( $pf.pod-body ),
        :path( $pf.path )
    } )
}

method processed-instance( :$name ) {
    PodCache::Processed.new(
        :$name,
        :pod-tree( self.pod($name) ),
        :path( $.files{$name}<path> ),
        :$!global-links,
        :templater( $!engine ),
        :$!debug,
        :$!verbose
    )
}

method process-cache {
    return if +%.pfiles.keys; # only do this once.
    for $.files.keys -> $filename {
        my $pf = self.processed-instance( :name($filename) );
        %.pfiles{$filename} = %(
            :$pf ,
        # todo include code for creating a single file
            :link("$filename.$!rendering"),
        );
        for $pf.index.kv -> $entry, @data {
            %!global-index{$entry} = Array unless %!global-index{$entry}:exists;
            for @data -> %item {
                %!global-index{$entry}.push: %(:target( "$filename.$!rendering" ~ %item<target>), :place( %item<place>), );
                # global-links is for testing, but index items should have correct links
                #@!global-links.push: %(:target( "$filename.$!rendering" ~ %item<target>), :place( %item<place>), :source($filename),)
            }
        }
        for $pf.links {
            @!global-links.push: %(|$_, :source($filename))
        }
    }
}

method templates-changed {
    $!engine.over-ridden, "from $!templates/$!rendering"
}

method links-test {
    self.process-cache;
    my LibCurl::Easy $curl .=new(:!verbose, :followlocation );
    my @responses =();
    for @.global-links.list -> %info {
        $curl.setopt(:URL( %info<target>));
        $curl.perform;
        CATCH {
            when X::LibCurl {
                @responses.push: qq:to/RESPONSE/;
                    Error: ｢{ %info<target> }｣ in source ｢{ %info<source> }｣ with label ｢{ %info<content> }｣
                    generated response ｢{$curl.response-code}｣ with error ｢{$curl.error}｣
                    RESPONSE
            }
        }
        unless $curl.success  {
            @responses.push(qq:to/ERROR/);
            Error: ｢{ %info<target> }｣ in source ｢{ %info<source> }｣ with label ｢{ %info<content> }｣
            generated response ｢{$curl.response-code}｣ with error ｢{$curl.error}｣
            ERROR
        }
    }
    note "Links responses are:\n", @responses.join("\n\t") if +@responses and $!verbose ;
    @responses
}

method update-collection {
    self.create-collection(self.list-files( Pod::To::Cached::Tainted ))
}

method create-collection(@names = %.pfiles.keys ) {
    self.process-cache;
    self.file-wrap( %.pfiles{$_}<pf> ) for @names
}

method test-index-files( :$quiet  = False  ) {
    self.process-cache;
    # No need to test global-index files because if there are items not in the section headers,
    # then they will be put into the Misc section
    my @index-files = dir($!config, :test(/ '.yaml' /) );
    unless +@index-files {
        note 'No index.yaml files so will generate defaults' if $!verbose;
        return
            %( :not-in-index( $.files.keys ),
                :not-in-cache( Nil ),
                :duplicates-in-index( Nil ),
                :index-and-cache( Nil ),
                :errors( 'No index.yaml files, so will generate default files' , ) )
    }
    my $residue = SetHash.new: $.files.keys;
    my $cache = Set.new: $.files.keys;
    my @index-and-cache = ();
    my @not-in-cache = ();
    my @duplicates-in-index = ();
    my @errors = ();
    my %single-index;
    for @index-files -> $fn {
        %single-index = load-yaml( $fn.slurp );
        CATCH {
            default {
                @errors.push: "With ｢{ $fn.basename }｣: { .payload }"
            }
        } # leaves for block if error found
        if %single-index<type>:exists and %single-index<type> eq 'global-index' {
            #TODO
        }
        else {
            @errors.push("With $fn: No title") unless %single-index<title>:exists;
            for %single-index<content>.kv -> $entry, %info {
                @errors.push("With $fn: No header text at entry # $entry")
                    if %info<header>:exists and %info<header><text>:!exists;
                if %info<item>:exists {
                    if %info<item><filename>:exists {
                        my $ifn = %info<item><filename>;
                        if $residue{ $ifn }-- {
                            @index-and-cache.push: ~$fn
                        }
                        else {
                            if $cache{ $ifn } {
                                @duplicates-in-index.push: ~$ifn
                            }
                            else {
                                @not-in-cache.push: ~$ifn
                            }
                        }
                    }
                    else {
                        @errors.push("With $fn: No item filename or ( link & title) at entry # $entry")
                            unless %info<item><link>:exists and  %info<item><title>:exists
                    }
                }
            }
        }
    }
    unless $quiet {
        note "Errors found: " ~
            (+@errors ?? ("\n\t" ~ @errors.join("\n\t")) !! "None" );
        note "Pod sources summary";
        note "Number in cache and in config file(s): ", +@index-and-cache;
        note "Source names in cache but not in config file(s): " ~
            (+$residue.keys ?? ("\n\t" ~ $residue.keys.join("\n\t")) !! "None" );
        note "Source names duplicated in config file(s): ",
            (+@duplicates-in-index ?? ("\n\t" ~ @duplicates-in-index.join("\n\t")) !! "None" );
        note "Source names not in cache but in config file(s): ",
            (+@not-in-cache ?? ("\n\t" ~ @not-in-cache.join("\n\t")) !! "None" );
    }
    %( :not-in-index( $residue.keys>>.Str ),
        :@not-in-cache,
        :@duplicates-in-index,
        :@index-and-cache,
        :@errors )
}

method write-indices {
    my %test = self.test-index-files(:quiet( ! $!verbose)); # make sure we can read the index files
    exit note "Cannot write index files because: " ~ %test<errors>.join("\n\t") if +%test<errors>;
    # if no yaml files in Config (default Output), generate two in Output
    my @index-files = dir($!config, :test(/ '.yaml' /) );
    unless +@index-files {
        #defaults when no given in CONFIG
        self.gen-index-files;
        @index-files = <index.yaml global-index.yaml>.map( "$!config/$_".IO );
        # these do not need to be tested because they are generated correctly
    }
    for @index-files {
        my %params = self.process-index( $_  );
        my $fn = .basename.substr( 0, *-5 ); #get rid of yaml
        "$!output/$fn.$!rendering".IO.spurt:
            $!engine.rendition((%params<type> eq 'global-index' ?? 'global-indexation-file' !! 'indexation-file'), %params);
    }

}

method process-index( $fn ) {
    my %index = load-yaml( $fn.slurp );
    my %params = :title(%index<title>), :body( Str ), :path( ~$fn ), :type( %index<type> // 'normal' );
    my $body := %params<body>;
    $body ~=
        $!engine.rendition('title', %( :text(%index<title>), :target<__top> ) )
        ~ ( %index<subtitle>:exists ?? $!engine.rendition('subtitle', %(:contents( %index<subtitle>) ) ) !! '' );

    with %index<type> and %index<type> eq 'global-index' {
        my SetHash $residue .= new: %.global-index.keys;
        for %index<content>.list -> %entry {
            $body ~= $!engine.rendition('global-indexation-heading', %(
                :level( %entry<level>),
                :text( %entry<head>),
            ) );
            my $rg = %entry<regex>;
            my @sect-entries;
            for $residue.keys {
                if m/ <$rg> / {
                    $residue{$_}--; # remove from set at first match
                    @sect-entries.push: %( :text( $_ ), :refs( %.global-index{$_} )  )
                }
            }
            $body ~= $!engine.rendition('global-indexation-defn-list', %( :list(@sect-entries)))
        }
        if +$residue.keys {
            # Not all the index entries have been used up by the regexes
            $body ~= $!engine.rendition('indexation-heading', {
                :2level,
                :text('Miscellaneous'),
            } );
            my @sect-entries;
            for $residue.keys {
                @sect-entries.push: %( :text( $_ ), :refs( %.global-index{$_} )  )
            }
            $body ~= $!engine.rendition('global-indexation-defn-list', %( :list(@sect-entries)))
        }
    }
    else {
        $body ~=
            [~] gather for %index<content>.list -> %entry {
                take $!engine.rendition('indexation-heading', %(
                    :level( %entry<header><level>),
                    :text(%entry<header><text>) ,
                    :subtitle( %entry<header><subtitle> // ''),
                ) ) if %entry<header>:exists;
                take $!engine.rendition('indexation-entry', self.pf-params( %entry<item> ) )
                    if %entry<item>:exists;
            }
        ;
    }
    %params
}

method pf-params( %info ) {
    if %info<filename>:exists and $.pfiles{%info<filename>}:exists {
        my PodCache::Processed $pf = $.pfiles{ %info<filename> }<pf>;
        # any link in the config file is ignored because it could distort links
        # if there is a use case for specifying links in the config, this is where the
        # code should probably exist. But links would need to be rewritten.

        %(
            :title( %info<title> // $pf.title // 'No title' ),
            :subtitle( %info<subtitle> // $pf.sub-title // '' ),
            :toc( (%info<toc>:!exists or (%info<toc>:exists and %info<toc>)) ?? $pf.toc !! '' ), # default = no <toc> = show toc
            :link( $.pfiles{ %info<filename> }<link> )
        )
    }
    else { # this is used when another file is linked to, in which case a title should be provided and a link.
        %(
            :title( %info<title> // 'No file name or title defined' ),
            :subtitle( %info<subtitle> // '' ),
            :toc( '' ), #No toc where no pod
            :link( %info<link> // '' )
        )
    }
}

sub proforma( Int $elems --> Array ) {
    given $elems {
        when * <= 10 {
            [
                %( :head('A(a) to P(p)'),  :regex( " ^ <[A..P,a..p]>  " ), :2level, ),
                %( :head('Q(q) to Z(z)'),  :regex( " ^ <[Q..Z,q..z]>  " ), :2level, ),
            ]
        }
        when 10 < * <= 50 {
            [
                %( :head('A(a) to E(e)'),  :regex( " ^ <[A..E,a..e]>  " ), :2level, ),
                %( :head('F(f) to J(j)'),  :regex( " ^ <[F..J,f..j]>  " ), :2level, ),
                %( :head('K(k) to O(o)'),  :regex( " ^ <[K..O,k..o]>  " ), :2level, ),
                %( :head('P(p) to S(s)'),  :regex( " ^ <[P..S,p..s]>  " ), :2level, ),
                %( :head('T(t) to Z(z)'),  :regex( " ^ <[T..Z,t..z]>  " ), :2level, ),
            ]
        }
        when * > 50 {
            [
                %( :head('A(a) to B(b)'),  :regex( " ^ <[A..B,a..b]>  " ), :2level, ),
                %( :head('C(c) to D(d)'),  :regex( " ^ <[C..D,c..d]>  " ), :2level, ),
                %( :head('E(e) to F(f)'),  :regex( " ^ <[E..F,e..f]>  " ), :2level, ),
                %( :head('G(g) to H(h)'),  :regex( " ^ <[G..H,g..h]>  " ), :2level, ),
                %( :head('I(i) to J(j)'),  :regex( " ^ <[I..J,i..j]>  " ), :2level, ),
                %( :head('K(k) to L(l)'),  :regex( " ^ <[K..L,k..l]>  " ), :2level, ),
                %( :head('M(m) to N(n)'),  :regex( " ^ <[M..N,m..n]>  " ), :2level, ),
                %( :head('O(o) to P(p)'),  :regex( " ^ <[O..P,o..p]>  " ), :2level, ),
                %( :head('Q(q) to R(r)'),  :regex( " ^ <[Q..R,q..r]>  " ), :2level, ),
                %( :head('S(s) to T(t)'),  :regex( " ^ <[S..T,s..t]>  " ), :2level, ),
                %( :head('U(u) to V(V)'),  :regex( " ^ <[U..V,u..v]>  " ), :2level, ),
                %( :head('W(w) to Z(z)'),  :regex( " ^ <[W..Z,w..z]>  " ), :2level, ),
            ]
        }
    }
}

sub data($item) {
    given $item {
        when 'index-start' {
            q:to/DATA/;
                ---
                # This is a configuration file that will be interpreted by C<PodCache::Render>
                # to create an index file containing all the files in the document cache
                # This file is generated with the intent that it can be a template for customised
                # index files.
                # Styling and presentation information should be contained in the template
                # used to render the index viz., indexation-file.
                # The indexation-file template should typically be over-ridden.

                # The structure of an index file is as follows
                # - title: text in the title # mandatory
                # - subtitle: paragraph immediately following the title # optional
                # - head:
                #    level: an optional attribute and will be used for the header level
                #    text: a required attribute. Is the text of the header
                #    subtitle: optional. Paragraph following heading.
                # - item:
                #      filename: the name of file in the document cache
                #        # if the filename is missing, no error is generated
                #        # if the file corresponding to the filename does not exist, no error is generated
                #        # Consequently, links other files, such as other index files, can be included by
                #        # ommiting the filename, or using one not in the cache, whilst providing
                #        # a link and text  (see below)
                #     # the following are optional and when absent, the data is taken from the pod file attributes
                #     title: the text to be used to refer to the filename in place of the pod's TITLE attribute
                #     subtitle: text used instead of the pod's SUBTITLE attribute
                #     link: the link to be used to refer to the file instead of the URL generated from the pod file name
                #     toc: whether or not to include the pod file's toc. Defaults to True

                title: Perl 6 Documentation
                subtitle: Links to the rendered pod files, one for each file in the document cache. Listed alphabetically.
                    Where pod files are arranged in sub-directories, the path is used as a heading.

                DATA
        }
        when 'global-index-start' {
            q:to/DATA/
                ---
                # This is a configuration file that will be interpreted by C<PodCache::Render>
                # to create a global index file containing all entries indexed in all the sources in the document cache
                # This file is generated with the intent that it can be a template for customised
                # index files.
                # Styling and presentation information should be contained in the template
                # used to render the global-index viz., global-indexation-file.
                # The global-indexation-file template should typically be over-ridden for custom css and js

                # The structure of the global-index.yaml file is as follows
                # - type: global-index # mandatory for the global-index
                #    # the intent of this option is to allow a different rendering for
                #    # landing page index files and global-indices
                # - title: To be in the title # mandatory
                # - subtitle: Paragraph immediately following the title # optional
                # - head: Separator between sections of index
                #   level: The heading level - typically 2
                #   text: The text in the header
                #   regex: The regex to be applied to the index entry for inclusion in this section
                #  # To generate the rendered global-index, the index entries are sorted alphabetically, compared
                #  # to the regex, and added to the first section whose regex matches.
                #
                # Any missing indexed entries not matched by a section will be added to
                # a Miscellaneous Section at the end.

                type: global-index
                title: Global Index of Perl 6 Documentation
                subtitle: Links to indexed items in all files in document collection.

                DATA
        }
    }
}
