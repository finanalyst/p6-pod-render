#! /usr/bin/env perl6
use v6.c;
use Template::Mustache;
use JSON::Fast;
use nqp;
use Pod::Cached;
no precompilation;
=begin pod
=TITLE Rendering pod

This module provides functionality to take a precompiled pod and generate
output based on templates. The default templates are for html and for a separate
HTML file for each source pod.

=begin SYNOPSIS

    use Pod::Render;

    my Pod::Render $renderer .= new(
        :path<path-to-pod-cache>,
        :templates<path-to-templates>,
        :output<path-to-output>,
        :rendering<html>,
        :!global-links
        );

=end SYNOPSIS
=item new
    - instantiates object and verifies cache is present
    - creates or empties the output directory
    - verifies that <templates>/<rendering> directory exists and contains
        a full set of templates

=item path
    - location of perl6 compunit cache, as generated by Pod::Cached
    - defaults to '.pod-cache'

=item templates
    - location of templates root directory
    - defaults to 'resources/templates', which is where a complete set of templates exists

=item output
    - the path where output is sent
    - default is a directory with the same name as C<rendering33>

=item rendering
    - the type of rendering chosen
    - default is html, and refers to templates/html in which a complete set of templates exists
    - any other valid directory name can be used, eg md, so long as templates/md contains
    a complete set of templates

=item global-links
    - boolean default False
    - if true href links in <a> tags must all be relative to collection (podfile appended to local link)
    - if false links need only be unique relative to Processed

=end pod

constant TOP = '__top';


unit class Pod::Render is Pod::Cached;

our $global-links; # whether links must be unique to collection (True), or to Pod file (Default False)
our %tmpl = (
    #| templates defined here without explicit html
    #| markup specific templates defined in mustache files.
    #| simple ones can be overidden by mustache files
    :escaped<{{ contents }}>,
    :raw<{{{ contents }}}>,
    :format-c-index('C<{{ contents }}>'),
    :zero(' '),
    ); # templates as strings
our $engine = Template::Mustache.new;
our $verbose;
our $rdebug = False; # debug for rendition method

has Str $!templates;
has Str $!rendering;
# list of the templates needed (not defined as short templates below)
has @!template-list = <
    bold code comment footnote footnotes format-c format-x heading index italic item
    link main notimplemented output para section subtitle table title toc>;
has $!output;

submethod BUILD(
    :$!templates = 'resources/templates',
    :$!rendering = 'html',
    :$!output = $!rendering,
    :$global-links = False,
    :$v = True,
    ) {}

submethod TWEAK {
    self.verify-templates;
}

method verify-templates {
    die "$!templates/$!rendering must be a directory" unless "$!templates/$!rendering".IO ~~ :d;
    my @errors = ();
    for @!template-list -> $tm {
        if "$!templates/$!rendering/$tm.mustache".IO ~~ :f {
            %tmpl{$tm} = "$!templates/$!rendering/$tm.mustache".IO.slurp;
        }
        else {
            @errors.push: "$tm.mustache must exist ";
        }
    }
    die "The following templates do not exist under $!templates/$!rendering"
        ~ @errors.join("\n\t")
        if +@errors;
    note 'Templates verified' if $verbose;
}

our sub rendition(Str $key, %params --> Str) {
    if $rdebug {
        say "key is $key";
        say 'params are: ';
        dd %params;
        say 'end params';
        say "\%tmpl\{$key} is: ";
        dd %tmpl{$key};
        say "end template";
    }
    my $rv = $engine.render( %tmpl{$key}, %params, :literal );
    say "rendered: ｢$rv｣" if $rdebug;
    $rv
}

class Processed {
    has Str $.name;
    has Str $.title is rw = '';
    has Str $.sub-title is rw = '';
    has Str $.top; # target for TITLE
    has $.pod-tree; # cached pod
    has Str $.pod-body; # generated html
    has @.toc = ();
    has %.index = ();
    has @.links = (); # for links outside the Processed
    has @.footnotes = ();
    has SetHash $.targets .= new; # target names are relative to Processed
    has Int @.counters is default(0);
    has Int $.debug;

    submethod BUILD  (:$!name, :$!pod-tree, :$!debug = 0 ) { }

    submethod TWEAK {
        $!top = self.unique-target( TOP );
        $rdebug = ($!debug > 1);
        self.process-pod;
    }

    method register-toc(:$level!, :$text! --> Str) {
        @!counters[$level - 1]++;
        @!counters.splice($level);
        my $target = self.unique-target('t_' ~ @!counters>>.Str.join: '_') ;
        @!toc.push: %( :$level, :$text, :$target);
        $target
    }
    method render-toc( --> Str ) {
        rendition('toc', { :toc( @!toc ) });
    }
    method register-index(:$text! is copy, :$place --> Str) {
        $text = 'blank' if $text ~~ / ^ \s* $ /;
        %.index{$text} = Array unless %.index{$text}:exists;
        my $target = self.unique-target("t_$text") ;
        %.index{$text}.push: %(:$target, :$place);
        $target
    }
    method render-index(-->Str) {
        rendition( 'index', { :index(gather for %!index.sort {  take %(:text(.key), :refs( [.value.sort] )) } ) } )
    }
    method !register-link(:$text!, :$link!, :$place) {
        @!links.push: %( :$text, :$link, :$place)
    }
    method register-footnote(:$text! --> Hash ) {
        my $fnNumber = +@!footnotes + 1;
        my $fnTarget = self.unique-target("fn$fnNumber") ;
        my $retTarget = self.unique-target("fnret$fnNumber");
        @!footnotes.push: {:$text, :$retTarget, :$fnNumber, :$fnTarget };
        (:$fnTarget, :$fnNumber, :$retTarget).hash
    }
    method render-footnotes(--> Str){
        rendition('footnotes', { :notes( @!footnotes ) } )
    }
    method process-pod {
        say "Processing pod for $.name" if $verbose;
        (say "pod-tree is:" and dd $!pod-tree) if $.debug > 0;
        $!pod-body = [~] $!pod-tree>>.&handle( self );
    }

    method unique-target(Str $name is copy --> Str ) {
        $name = $name.subst(/\s+\.*|\./,'_',:g).subst(/<-alnum>/,'',:g).substr(0,15);
        $name ~= '_1' if $name (<) $!targets;
        ++$name while $!targets{$name};
        my $prefix = '#' ~ ($global-links ?? $!name.subst([\/], '_') !! '');
        $prefix ~ $name
    }

    my enum Context ( None => 0, Index => 1 , Heading => 2, HTML => 3, Raw => 4, Output => 5);

    #| Multi for handling different types of Pod blocks.
    multi sub handle (Pod::Block::Code $node, Processed $pf  --> Str ) {
        my $addClass = $node.config && $node.config<class> ?? ' ' ~ $node.config<class> !! '';
        rendition('code', {:$addClass, :contents( [~] $node.contents>>.&handle( $pf ) )} )
    }

    multi sub handle (Pod::Block::Comment $node, Processed $pf  --> Str ) {
        rendition('zero', {:contents([~] $node.contents>>.&handle( $pf ))});
    }

    multi sub handle (Pod::Block::Declarator $node, Processed $pf  --> Str ) {
        rendition('notimplemented', {:contents([~] $node.contents>>.&handle( $pf ))});
    }

    multi sub handle (Pod::Block::Named $node, Processed $pf  --> Str ) {
        rendition('section', { :name($node.name), :contents( [~] $node.contents>>.&handle( $pf ))  });
    }

    multi sub handle (Pod::Block::Named $node where $node.name eq 'TITLE', Processed $pf --> Str ) {
        my $addClass = ($node.config && $node.config<class> ?? ' ' ~ $node.config<class> !! '');
        my $text = $pf.title = $node.contents[0].contents[0].Str;
        my $target = $pf.top;
        rendition('title', {:$addClass, :$target, :$text } )
    }

    multi sub handle (Pod::Block::Named $node where $node.name eq 'SUBTITLE', Processed $pf --> Str ) {
        my $addClass = ($node.config && $node.config<class> ?? ' ' ~ $node.config<class> !! '').subst('"', '&quot;');
        my $content = $node.contents[0].contents[0].Str;
        rendition('subtitle', {:$addClass, :$content } )
    }

    multi sub handle (Pod::Block::Named $node where $node.name eq 'Html' , Processed $pf--> Str ) {
        [~] $node.contents>>.&handle($pf, HTML) ;
    }

    multi sub handle (Pod::Block::Named $node where .name eq 'output', Processed $pf  --> Str ) {
        rendition('output', {:contents( [~] $node.contents>>.&handle($pf, Output) ) } )
    }

    multi sub handle (Pod::Block::Para $node, Processed $pf, Context $context where * == Output  --> Str ) {
        [~] $node.contents».&handle( $pf ).join
    }

    multi sub handle (Pod::Block::Para $node, Processed $pf , Context $context? = None --> Str ) {
        my $addClass = ($node.config && $node.config<class> ?? ' ' ~ $node.config<class> !! '').subst('"', '&quot;');
        rendition('para', {:$addClass, :contents( [~] $node.contents>>.&handle( $pf ) ) } );
    }

    multi sub handle (Pod::Block::Para $node, Processed $pf, Context $context where * != None  --> Str ) {
        $node.contents>>.&handle($pf, $context).join('');
    }

    multi sub handle (Pod::Block::Table $node, Processed $pf  --> Str ) {
        my $addClass = ($node.config && $node.config<class> ?? ' ' ~ $node.config<class> !! '').subst('"', '&quot;');
        my @headers = gather for $node.headers { take .&handle( $pf ) };
        rendition( 'table', {
                :$addClass,
                :caption( $node.caption ?? $node.caption.&handle( $pf ) !! ''),
                :headers( +@headers ?? %( :cells( @headers ) ) !! Nil ),
                :rows( [ gather for $node.contents -> @r {
                    take %( :cells( [ gather for @r { take .&handle( $pf ) } ] )  )
                } ] ),
            } );
    }

    multi sub handle (Pod::Heading $node, Processed $pf --> Str ) {
        my $addClass = ($node.config && $node.config<class> ?? ' ' ~ $node.config<class> !! '').subst('"', '&quot;');
        my $level = $node.level;
        my $text = [~] $node.contents>>.&handle($pf, Heading);
        my $target = $pf.register-toc( :$level, :$text );
        rendition('heading', {
            :$level,
            :$text,
            :$addClass,
            :$target,
            :top( $pf.top )
        })
    }

    multi sub handle (Pod::Item $node, Processed $pf --> Str  ) {
        my $addClass = ($node.config && $node.config<class> ?? ' ' ~ $node.config<class> !! '').subst('"', '&quot;');
        rendition('item', {:$addClass, :contents([~] $node.contents>>.&handle( $pf ) ) } );
    }

    # note no template needed
    multi sub handle (Pod::Raw $node, Processed $pf --> Str ) {
        [~] $node.contents>>.&handle( $pf )
    }

    multi sub handle (Str $node, Processed $pf, Context $context? = None --> Str ) {
        rendition('escaped', {:contents(~$node)});
    }

    multi sub handle (Str $node, Processed $pf, Context $context where * == HTML --> Str ) {
        rendition('raw', {:contents(~$node)})
    }

    multi sub handle (Nil) {
        die 'Nil';
    }

    multi sub handle (Pod::Config $node, Processed $pf  --> Str ) {
        rendition('comment',{:contents($node.type ~ '=' ~ $node.config.perl) } )
    }

    multi sub handle (Pod::FormattingCode $node, Processed $pf, Context $context where * == Raw   --> Str ) {
        [~] $node.contents>>.&handle($pf, $context).join('');
    }

    multi sub handle (Pod::FormattingCode $node where .type eq 'B', Processed $pf, Context $context = None   --> Str ) {
        my $addClass = $node.config && $node.config<class> ?? $node.config<class>.subst('"', '&quot;') !! '';
        rendition('bold',{:$addClass, :contents( [~] $node.contents>>.&handle($pf, $context) ) })
    }

    multi sub handle (Pod::FormattingCode $node where .type eq 'C', Processed $pf, Context $context = None   --> Str ) {
        my $addClass = ($node.config && $node.config<class> ?? ' ' ~ $node.config<class> !! '').subst('"', '&quot;');
        rendition('format-c', {:$addClass, :contents([~] $node.contents>>.&handle( $pf, $context ).join('') ) } );
    }

    multi sub handle (Pod::FormattingCode $node where .type eq 'C', Processed $pf, Context $context where * ~~ Index = None   --> Str ) {
        rendition('format-c-index', {:contents( [~] $node.contents>>.&handle( $pf ).join('') )})
    }

    # no template.
    multi sub handle (Pod::FormattingCode $node where .type eq 'E', Processed $pf, Context $context = None   --> Str ) {
        $node.meta.map({ when Int { "&#$_;" }; when Str { "&$_;" }; $_ }).join
    }

    multi sub handle (Pod::FormattingCode $node where .type eq 'Z', Processed $pf, $context = None   --> Str ) {
        rendition('comment',{:contents([~] $node.contents>>.&handle($pf, $context)) } )
    }

    multi sub handle (Pod::FormattingCode $node where .type eq 'I', Processed $pf, Context $context = None   --> Str ) {
        my $addClass = $node.config && $node.config<class> ?? $node.config<class>.subst('"', '&quot;') !! '';
        rendition('italic',{:$addClass, :contents( [~] $node.contents>>.&handle($pf, $context) ) })
    }

    multi sub handle (Pod::FormattingCode $node where .type eq 'X', Processed $pf, Context $context = None   --> Str ) {
        my $addClass = $node.config && $node.config<class> ?? $node.config<class>.subst('"', '&quot;') !! '';
        my $text = [~] $node.contents>>.&handle($pf, $context);
        my $place = [~] $node.meta;
        my $target = $pf.register-index( :$text, :$place );
        rendition('format-x',{:$addClass, :$text, :$target,  :header( $context ~~ Heading ) })
    }

    multi sub handle (Pod::FormattingCode $node where .type eq 'N', Processed $pf, Context $context = None --> Str ) {
        my $text = [~] $node.contents>>.&handle($context);
        rendition('footRef', $pf.register-footnote(:$text) )
    }

    multi sub handle (Pod::FormattingCode $node where .type eq 'L', Processed $pf, $context = None   --> Str ) {
        my $addClass = ($node.config && $node.config<class> ?? ' ' ~ $node.config<class> !! '').subst('"', '&quot;');
        my $content = [~] $node.contents>>.&handle($pf, $context);
        my $target = $node.meta eqv [] | [""] ?? $content !! $node.meta;
        $pf.links.push: $target;
        # link handling needed here to deal with local links in global-link context

        rendition('link', {:$target, :$addClass, :contents([~] $node.contents>>.&handle( $pf, $context ) ) } );
    }

    =begin takeout
    #| the following format codes are not in the POD documentation, but in Synopsis
    #| the following is code from BigPage.pm6, on which this module is based
    multi sub handle (Pod::FormattingCode $node where .type eq 'F', Processed $pf, $context = None   --> Str ) {
        my $addClass = ($node.config && $node.config<class> ?? ' ' ~ $node.config<class> !! '').subst('"', '&quot;');
        rendition('format-f', {:$addClass, :contents($node.contents>>.&handle( $pf, $context ) ) } );
    }
    # mustache would be:
    # <span class="filename{{# addClass }} {{ addClass }}{{/ addClass }}">{{ content }}</span>

    multi sub handle (Pod::FormattingCode $node where .type eq 'P', $context = None, :$pod-name?, :$part-number?, :$toc-counter?) {
        my $content = $node.contents>>.&handle($context).Str;
        my $link = $node.meta eqv [] | [""] ?? $content !! $node.meta;

        use LWP::Simple;
        my @url = LWP::Simple.parse_url($link);
        my $doc;
        given @url[0] {
            when 'http' | 'https' {
                $doc = LWP::Simple.get($link);
            }
            when 'file' {
                $doc = slurp(@url[3]);
            }
            when '' {
                $doc = slurp(@url[3]);
            }
        }
        if $doc {
            given @url[3].split('.')[*-1] {
                when 'txt' { return '<pre>' ~ $doc.&escape-markup ~ '</pre>'; }
                when 'html' | 'xhtml' { return $doc }
            }
        }
        warn "did not inline $link";
        q:c{<a href="{$link}">{$content}</a>}
    }

    multi sub handle (Pod::FormattingCode $node where .type eq 'R', $context = None, :$pod-name?, :$part-number?, :$toc-counter?) {
        '<var class="replaceable">' ~ $node.contents>>.&handle($context) ~ '</var>'
    }

    multi sub handle (Pod::FormattingCode $node where .type eq 'V', $context = None, :$pod-name?, :$part-number?, :$toc-counter?) {
        '' ~ $node.contents>>.&handle($context) ~ ''
    }


        # NYI
        # multi sub handle (Pod::Block::Ambient $node) {
        #   $node.perl.say;
        #   $node.contents>>.&handle;
        # }
    =end takeout

} # end of Processed class

method processed-instance(:$name, :$pod-tree, Int :$debug = 0) { Processed.new(:$name, :$pod-tree, :$debug) }

method get-tmpl( --> Hash) { %tmpl }
